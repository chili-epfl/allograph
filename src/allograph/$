#!/usr/bin/env python
# coding: utf-8

"""
library of algorithms to compare hand-written strokes
"""


import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

class Stroke:
    """ a stroke object is a collection of x coordinates and y coordinates that describes the points inside a 1-stroke shape """

    def __init__(self, x=[], y=[]):
        self.x = x
        self.y = y

        # self.len is the number of points in the stroke
        self.len = min(len(self.x),len(self.y))

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    def get_len(self):
        return self.len

    def append(self,x,y):
        """ add the point (x,y) to the stroke """

        self.x.append(x)
        self.y.append(y)
        self.len+=1

    def reset(self):
        self.x = []
        self.y = []
        self.len = 0

    def plot(self):
        plt.plot(self.x,self.y)
        plt.plot(self.x,self.y,'r.')

    def stroke_from_xxyy(self, shape):
        self.x = shape[0:len(shape)/2]
        self.y = shape[len(shape)/2:]
        self.len = len(self.x)

    def downsampleShape(self, numDesiredPoints):
        """ change the length of a stroke with interpolation"""

        if len(self.x)>2:
            t_current = np.linspace(0, 1, len(self.x))
            t_desired = np.linspace(0, 1, numDesiredPoints)

            f = interpolate.interp1d(t_current, self.x, kind='linear')
            self.x = f(t_desired).tolist()
            f = interpolate.interp1d(t_current, self.y, kind='linear')
            self.y = f(t_desired).tolist()

            self.len = numDesiredPoints

    def euclidian_length(self):
        """comput length of the shape """

        shape_length = 0
        last_x = self.x
        last_y = self.y
        scale = [0]
        for i in range(self.len-1):
            x = np.array(self.x[i+1])
            y = np.array(self.y[i+1])
            last_x = np.array(self.x[i])
            last_y = np.array(self.y[i])
            shape_length += np.sqrt((x-last_x)**2 + (y-last_y)**2)
            scale.append(shape_length)
        return shape_length, scale


    def uniformize(self):
        """make the distribution of points in the stroke equidistants """

        self.len = len(self.x)

        if self.len>1:
            # comput length of the shape:
            shape_length,scale = self.euclidian_length()

            # find new points:
            new_shape = Stroke()
            new_shape.x = []
            new_shape.y = []
            step = shape_length/float(self.len)
            biggest_smoller_point = 0
            new_shape.append(self.x[0], self.y[0])
            for i in 1+np.array(range(len(self.x)-1)):
                try:
                    while i*step > scale[biggest_smoller_point]:
                        biggest_smoller_point += 1

                    biggest_smoller_point -= 1
                    x0 = self.x[biggest_smoller_point]
                    y0 = self.y[biggest_smoller_point]
                    x1 = self.x[biggest_smoller_point+1]
                    y1 = self.y[biggest_smoller_point+1]
                    diff = float(i*step-scale[biggest_smoller_point])
                    dist = float(scale[biggest_smoller_point+1]-scale[biggest_smoller_point])
                    new_x = x0 + diff*(x1-x0)/dist
                    new_y = y0 + diff*(y1-y0)/dist
                    new_shape.append(new_x, new_y)

                except IndexError:
                    print i*step
                    print biggest_smoller_point
                    print scale
            #new_shape.append(self.x[-1], self.y[-1])


            self.x = new_shape.x
            self.y = new_shape.y
            self.len = new_shape.len


    def revert(self):
        """ revert a stroke : [x1,x2,x3] --> [x3,x2,x1] """ 

        x = self.x[::-1]
        y = self.y[::-1]
        return Stroke(x,y)

    def get_center(self):
        """ compute the gravity center of a stroke """

        x = np.array(self.x)
        y = np.array(self.y)
        return np.mean(x), np.mean(y)

    def normalize(self):
        """ normalize the stroke """

        x_min = min(self.x)
        x_max = max(self.x)
        y_min = min(self.y)
        y_max = max(self.y)

        x_range = x_max - x_min
        y_range = y_max - y_min

        x = np.array(self.x)
        y = np.array(self.y)
        x -= x_min
        y -= y_min
        x = x/float(x_range)
        y = y/float(y_range)

        self.x = x.tolist()
        self.y = y.tolist()

    def normalize_wrt_x(self):
        """ normalize the stroke with respect to the x axis """

        x_min = min(self.x)
        x_max = max(self.x)
        y_min = min(self.y)

        x_range = x_max - x_min

        x = np.array(self.x)
        y = np.array(self.y)
        x -= x_min
        y -= y_min
        x = x/float(x_range)
        y = y/float(x_range)

        self.x = x.tolist()
        self.y = y.tolist()

    def split_non_differentiable_points(self,treshold=1.5):
        """ V --> \+/ """

        #split_points = Stroke()
        splited_strokes = []
        current_stroke = Stroke()
        if len(self.x)>3:
            current_stroke.append(self.x[0],self.y[0])
            for i in range(len(self.x)-3):
                x1 = float(self.x[i])
                x2 = float(self.x[i+1])
                x3 = float(self.x[i+2])
                y1 = float(self.y[i])
                y2 = float(self.y[i+1])
                y3 = float(self.y[i+2])
                triangle_ratio = (np.sqrt((x1-x2)**2+(y1-y2)**2)+np.sqrt((x3-x2)**2+(y3-y2)**2))/(np.sqrt((x1-x3)**2+(y1-y3)**2)+0.0001)
                current_stroke.append(x2,y2)
                if triangle_ratio>treshold:
                    splited_strokes.append(current_stroke)
                    current_stroke = Stroke()
            if current_stroke.get_x():
                splited_strokes.append(current_stroke)

            return splited_strokes
        else:
            return self

# static functions:
#------------------

def plot_list(strokes):

    length = len(strokes)
    for i in range(length):
        plt.subplot(1,length,i)
        strokes[i].plot()
    #plt.show()

def smart_split(strokes):
    """ split at non-differentiable points of each stroke of 'strokes' """

    splited = []
    for stroke in strokes:
        splited += stroke.split_non_differentiable_points()
    return splited

def concat(strokes):
    """ concatenate all the strokes of a multistroke drawing """

    long_stroke = Stroke()
    for stroke in strokes:
        long_stroke.x += stroke.x
        long_stroke.y += stroke.y
        long_stroke.len += stroke.len
    return long_stroke

def smart_concat(strokes):
    """ if a stroke starts where another ends --> concat """

    # compute the average of spaces between connected points
    total_length = 0
    for stroke in strokes:
        length,_ = stroke.euclidian_length()
        total_length += length
    space = total_length/float(len(strokes)*7+0.00001)

    i = 0
    while len(strokes[i+1:])>0:
        test = False
        stroke = strokes[i]
        indice = i
        for stroke_i in strokes[i+1:]:

            indice += 1
            x11 = stroke.get_x()[-1]
            x21 = stroke_i.get_x()[0]
            y11 = stroke.get_y()[-1]
            y21 = stroke_i.get_y()[0]

            x12 = stroke.get_x()[-2]
            x22 = stroke_i.get_x()[1]
            y12 = stroke.get_y()[-2]
            y22 = stroke_i.get_y()[1]
            dist = np.sqrt((x11-x21)**2 + (y11-y21)**2)

            dx1 = x11-x12
            dx2 = x21-x11
            dx3 = x22-x21
            dx = [dx1,dx2,dx3]
            #print dx

            dy1 = y11-y12
            dy2 = y21-y11
            dy3 = y22-y21
            dy = [dy1,dy2,dy3]
            #print dy

            good_angle = False
            """if dx1*dx3<0 and dy1*dy3<0:
                good_angle = True"""

            if max(dx)*min(dx)>-10 and max(dy)*min(dy)>-10:
                good_angle = True

            if dist<space and good_angle:
                test = True
                strokes[i] = concat([stroke,stroke_i])
                strokes[indice:-1]=strokes[indice+1:]
                strokes = strokes[:-1]
                break
        if not test:
            i += 1

    return strokes


def smart_merging(strokes,threshold=0.05):
    """ if we draw two times the same shape at the same place, forget the smaller one """

    new_strokes = []
    while len(strokes)>1:
        test = True
        indice = 0
        for stroke in strokes[1:]:
            indice += 1
            score1 = identify([stroke],strokes[0])
            score2 = identify([strokes[0]],stroke)
            score = min(score1,score2)
            length1,_ = stroke.euclidian_length()
            length2,_ = strokes[0].euclidian_length()
            score = score/(min(length1,length2)+0.0001)
            if score<threshold:
                test = False
                break
        if test: # that means the stroke has'nt any twin
            copy = Stroke(strokes[0].get_x(),strokes[0].get_y())
            new_strokes.append(copy)
        else:
            # we want to keep the bigger:
            size1 = strokes[indice].euclidian_length()
            size2 = strokes[0].euclidian_length()
            if size2>size1:
                strokes[indice] = strokes[0]

        strokes = strokes[1:]

    # add the last one (we deleted all his possible twins)
    new_strokes.append(strokes[0])
    return new_strokes

def group_normalize(strokes):
    """ normilize a multistroke drawing """

    long_stroke = concat(strokes)
    x_min = min(long_stroke.x)
    x_max = max(long_stroke.x)
    y_min = min(long_stroke.y)
    y_max = max(long_stroke.y)
    x_range = float(x_max-x_min)
    y_range = float(y_max-y_min)
    normalized_strokes = []
    for stroke in strokes:
        x = ((np.array(stroke.x) - x_min)/x_range).tolist()
        y = ((np.array(stroke.y) - y_min)/y_range).tolist()
        normalized_strokes.append(Stroke(x,y))
    return normalized_strokes

def group_normalize_wrt_x(strokes):
    """ normailize a multistroke drawing with respect to the x axis """

    long_stroke = concat(strokes)
    x_min = min(long_stroke.x)
    x_max = max(long_stroke.x)
    y_min = min(long_stroke.y)
    x_range = float(x_max-x_min)
    normalized_strokes = []
    for stroke in strokes:
        x = ((np.array(stroke.x) - x_min)/x_range).tolist()
        y = ((np.array(stroke.y) - y_min)/x_range).tolist()
        normalized_strokes.append(Stroke(x,y))
    return normalized_strokes

def best_aligment(stroke1, stroke2, indice=None):
    """compare naive euclidian distance, smart euclidian distance 
       and smart euclidian distance after reverting one of the two strokes
       stroke1 and stroke2 must have the same size, otherwize we take the size of the smallest and cut the other"""
    
    # PATHOLOGIC CASES :
    if min(len(stroke1.x),len(stroke2.x))==0:
        return 0,0,0,0,0,0

    if indice and indice<len(stroke2.x):
        stroke2 = Stroke(stroke2.x[indice:],stroke2.y[indice:])

    if len(stroke1.x)>len(stroke2.x):
        stroke1 = Stroke(stroke1.x[:len(stroke2.x)], stroke1.y[:len(stroke2.y)])

    if len(stroke2.x)>len(stroke1.x):
        stroke2 = Stroke(stroke2.x[:len(stroke1.x)], stroke2.y[:len(stroke1.y)])

    # ALGORITHM :
    (nx1,ny1,d1,d2,m1,m2) = align(stroke1,stroke2)
    (rx1,ry1,d3,d4,m3,m4) = align(stroke1.revert(),stroke2)

    if np.sum(m4)<np.sum(m2):
        nx1 = rx1
        ny1 = ry1
        d2 = d4
        m2 = m4

    if np.sum(m1)<np.sum(m2):
        nx1 = stroke1.x
        ny1 = stroke2.y
        d2 = d1
        m2 = m1

    if np.sum(m3)<np.sum(m2):
        nx1 = stroke1.revert().x
        ny1 = stroke2.revert().y
        d2 = d3
        m2 = m3

    return nx1,ny1,np.mean(d2),np.mean(m2),d2,m2

def align(stroke1, stroke2):
    """aligne two strokes in order to compute 
       the euclidian distance between them in a smart way"""

    x1 = np.array(stroke1.x)
    x2 = np.array(stroke2.x)
    y1 = np.array(stroke1.y)
    y2 = np.array(stroke2.y)

    d = np.sqrt((x1-x2)**2+(y1-y2)**2)
    m = d-np.min(d)

    Ix1 = np.argmax(x1)
    Ix2 = np.argmax(x2)
    Iy1 = np.argmax(y1)
    Iy2 = np.argmax(y2)

    ix1 = np.argmin(x1)
    ix2 = np.argmin(x2)
    iy1 = np.argmin(y1)
    iy2 = np.argmin(y2)

    # rephasing :
    u = np.array([(Ix1-Ix2),(Iy1-Iy2),(ix1-ix2),(iy1-iy2)])
    indice_period = np.argmin(np.abs(u))
    period = u[indice_period]
    new_x1 = np.array(x1[period:].tolist() + x1[0:period].tolist())
    new_y1 = np.array(y1[period:].tolist() + y1[0:period].tolist())
    x1 = new_x1
    y1 = new_y1

    # resorting : if symetric part, revert it
    mx =  np.max((x1,x2),0)
    my =  np.max((y1,y2),0)
    sym_score = abs(x1-x2[::-1])+abs(y1-y2[::-1])
    if len(x1[sym_score<50])>20:
        x1[sym_score<40] = x1[sym_score<40][::-1]
        y1[sym_score<40] = y1[sym_score<40][::-1]

    new_d = np.sqrt((x1-x2)**2+(y1-y2)**2)
    new_m = new_d - min(new_d)

    return x1, y1, d, new_d, m, new_m

def euclidian_distance(stroke1, stroke2):
    """the euclidian distance between two strokes"""

    x1 = np.array(stroke1.x)
    x2 = np.array(stroke2.x)
    y1 = np.array(stroke1.y)
    y2 = np.array(stroke2.y)

    d = np.sqrt((x1-x2)**2+(y1-y2)**2)
    m = d-np.min(d)
    return np.mean(d), np.mean(m)

def identify(strokes, stroke, closest=True):
    """ look for the best matching postion of a stroke inside a concatenation of a multistroke drawing """

    # better : 1) unifore stroke/stroke ~ relative distance, 2) concatenate

    stroke_length,_ = stroke.euclidian_length()
    stroke.uniformize()
    stroke_num_points = len(stroke.get_x())

    uniformized_strokes = []
    for stroke_i in strokes:
        stroke_i_length,_ = stroke_i.euclidian_length()
        stroke_i.uniformize()
        numDesiredPoints = int(stroke_num_points*float(stroke_i_length)/(float(stroke_length)+0.0001))
        stroke_i.downsampleShape(numDesiredPoints)
        uniformized_strokes.append(stroke_i)

    draw = concat(uniformized_strokes)
    draw.len = len(draw.x)

    pose = 0
    _,_,best_score,best_match,_,best_values = best_aligment(stroke, draw, pose)

    if closest:
        for i in 1+np.array(range(draw.get_len()-stroke.get_len()+1)):
            _,_,score,match,_,values = best_aligment(stroke, draw, i)
            if score<best_score:
                best_score = score
                best_match = match
                best_values = values
                pose = i
    else:
        for i in 1+np.array(range(draw.get_len()-stroke.get_len()+1)):
            _,_,score,match,_,values = best_aligment(stroke, draw, i)
            if match<best_match:
                best_score = score
                best_match = match
                best_values = values
                pose = i

    #print best_score

    split_points = draw.split_non_differentiable_points(1.5)

    #plt.plot(draw.x,draw.y,'bo')
    #plt.plot(draw.x[pose:pose+stroke.len],draw.y[pose:pose+stroke.len],'rs')
    #plt.plot(split_points.x,split_points.y,'gs')
    #plt.show()

    if closest:
        return best_score
    else:
        return best_match

def compare(strokes1, strokes2):
    """ takes two multistrokes drawing, alignes them and then compute the euclidian distance """

    score = 0
    for stroke in strokes1:
        _,_,match = identify(strokes2,stroke)
        score += match
    
    draw1 = concat(strokes1)
    draw2 = concat(strokes2)
    draw1_length,_ = draw1.euclidian_length()
    draw2_length,_ = draw2.euclidian_length()

    tot_length = draw1_length# + draw2_length

    return 100*score/tot_length
